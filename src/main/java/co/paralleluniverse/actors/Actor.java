/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package co.paralleluniverse.actors;

import co.paralleluniverse.common.util.Exceptions;
import co.paralleluniverse.lwthreads.LightweightThread;
import co.paralleluniverse.lwthreads.SuspendExecution;
import co.paralleluniverse.lwthreads.SuspendableCallable;
import co.paralleluniverse.lwthreads.SuspendableRunnable;
import co.paralleluniverse.lwthreads.channels.Channel;
import co.paralleluniverse.lwthreads.channels.ObjectChannel;
import co.paralleluniverse.lwthreads.channels.SendChannel;
import co.paralleluniverse.lwthreads.queues.QueueCapacityExceededException;
import java.util.Collections;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import jsr166e.ConcurrentHashMapV8;
import jsr166e.ForkJoinPool;

/**
 *
 * @author pron
 */
public abstract class Actor<Message, V> extends LightweightThread<V> {
    private static final Map<String, Actor> registeredActors = new ConcurrentHashMapV8<String, Actor>();
    private final ObjectChannel<Object> mailbox;
    private final Set<LifecycleListener> lifecycleListeners = Collections.newSetFromMap(new ConcurrentHashMapV8<LifecycleListener, Boolean>());
    private volatile RuntimeException thrownIn;

    //<editor-fold defaultstate="collapsed" desc="Constructors">
    /////////// Constructors ///////////////////////////////////
    @SuppressWarnings("LeakingThisInConstructor")
    public Actor(String name, ForkJoinPool fjPool, int stackSize, int mailboxSize, SuspendableCallable<V> target) {
        super(name, fjPool, stackSize, target);
        this.mailbox = ObjectChannel.create(this, mailboxSize);
    }

    @SuppressWarnings("LeakingThisInConstructor")
    public Actor(String name, int stackSize, int mailboxSize, SuspendableCallable<V> target) {
        super(name, stackSize, target);
        this.mailbox = ObjectChannel.create(this, mailboxSize);
    }

    public Actor(String name, ForkJoinPool fjPool, int stackSize, int mailboxSize) {
        this(name, fjPool, stackSize, mailboxSize, (SuspendableCallable) null);
    }

    public Actor(String name, ForkJoinPool fjPool, int mailboxSize) {
        this(name, fjPool, -1, mailboxSize, (SuspendableCallable) null);
    }

    public Actor(ForkJoinPool fjPool, int stackSize, int mailboxSize) {
        this(null, fjPool, stackSize, mailboxSize, (SuspendableCallable) null);
    }

    public Actor(ForkJoinPool fjPool, int mailboxSize) {
        this(null, fjPool, -1, mailboxSize, (SuspendableCallable) null);
    }

    public Actor(String name, int stackSize, int mailboxSize) {
        this(name, stackSize, mailboxSize, (SuspendableCallable) null);
    }

    public Actor(String name, int mailboxSize) {
        this(name, -1, mailboxSize, (SuspendableCallable) null);
    }

    public Actor(int stackSize, int mailboxSize) {
        this((String) null, stackSize, mailboxSize, (SuspendableCallable) null);
    }

    public Actor(int mailboxSize) {
        this((String) null, -1, mailboxSize, (SuspendableCallable) null);
    }

    public Actor(String name, ForkJoinPool fjPool, int mailboxSize, SuspendableCallable<V> target) {
        this(name, fjPool, -1, mailboxSize, target);
    }

    public Actor(ForkJoinPool fjPool, int stackSize, int mailboxSize, SuspendableCallable<V> target) {
        this(null, fjPool, stackSize, mailboxSize, target);
    }

    public Actor(ForkJoinPool fjPool, int mailboxSize, SuspendableCallable<V> target) {
        this(null, fjPool, -1, mailboxSize, target);
    }

    public Actor(String name, int mailboxSize, SuspendableCallable<V> target) {
        this(name, -1, mailboxSize, target);
    }

    public Actor(int stackSize, int mailboxSize, SuspendableCallable<V> target) {
        this((String) null, stackSize, mailboxSize, target);
    }

    public Actor(int mailboxSize, SuspendableCallable<V> target) {
        this((String) null, -1, mailboxSize, target);
    }

    public Actor(String name, ForkJoinPool fjPool, int stackSize, int mailboxSize, SuspendableRunnable target) {
        this(name, fjPool, stackSize, mailboxSize, (SuspendableCallable) wrap(target));
    }

    public Actor(String name, int stackSize, int mailboxSize, SuspendableRunnable target) {
        this(name, stackSize, mailboxSize, (SuspendableCallable) wrap(target));
    }

    public Actor(String name, ForkJoinPool fjPool, int mailboxSize, SuspendableRunnable target) {
        this(name, fjPool, -1, mailboxSize, target);
    }

    public Actor(ForkJoinPool fjPool, int stackSize, int mailboxSize, SuspendableRunnable target) {
        this(null, fjPool, stackSize, mailboxSize, target);
    }

    public Actor(ForkJoinPool fjPool, int mailboxSize, SuspendableRunnable target) {
        this(null, fjPool, -1, mailboxSize, target);
    }

    public Actor(String name, int mailboxSize, SuspendableRunnable target) {
        this(name, null, -1, mailboxSize, target);
    }

    public Actor(int stackSize, int mailboxSize, SuspendableRunnable target) {
        this((String) null, stackSize, mailboxSize, target);
    }

    public Actor(int mailboxSize, SuspendableRunnable target) {
        this((String) null, -1, mailboxSize, target);
    }

    //</editor-fold>
    //<editor-fold desc="Mailbox methods">
    /////////// Mailbox methods ///////////////////////////////////
    public SendChannel<Message> getMaibox() {
        return (Channel<Message>) mailbox;
    }

    protected Message receive() throws SuspendExecution, InterruptedException {
        for (;;) {
            checkThrownIn();
            Object m = mailbox.receive();
            if (m instanceof LifecycleMessage)
                handleLifecycleMessage((LifecycleMessage) m);
            else
                return (Message) m;
        }
    }

    protected Message receive(long timeout, TimeUnit unit) throws SuspendExecution, InterruptedException {
        for (;;) {
            checkThrownIn();
            Object m = mailbox.receive();
            if (m instanceof LifecycleMessage)
                handleLifecycleMessage((LifecycleMessage) m);
            else
                return (Message) m;
        }
    }

    private MessageProcessor<Object> wrapProcessor(final MessageProcessor<Message> proc) {
        return new MessageProcessor<Object>() {
            @Override
            public boolean process(Object message) throws SuspendExecution, InterruptedException {
                if (message instanceof LifecycleMessage) {
                    handleLifecycleMessage((LifecycleMessage) message);
                    return true;
                }
                return proc.process((Message) message);
            }
        };
    }

    protected Message receive(long timeout, TimeUnit unit, Message currentMessage, MessageProcessor<Message> proc) throws SuspendExecution, InterruptedException {
        checkThrownIn();
        return (Message) mailbox.receive(timeout, unit, currentMessage, wrapProcessor(proc));
    }

    protected Message receive(Message currentMessage, MessageProcessor<Message> proc) throws SuspendExecution, InterruptedException {
        return receive(0, null, currentMessage, proc);
    }

    protected Message receive(long timeout, TimeUnit unit, MessageProcessor<Message> proc) throws SuspendExecution, InterruptedException {
        return receive(timeout, unit, null, proc);
    }

    protected Message receive(MessageProcessor<Message> proc) throws SuspendExecution, InterruptedException {
        return receive(0, null, null, proc);
    }

    public void send(Message message) {
        try {
            mailbox.send(message);
        } catch (QueueCapacityExceededException e) {
            throwIn(e);
        }
    }

    public void sendSync(Message message) {
        try {
            mailbox.sendSync(message);
        } catch (QueueCapacityExceededException e) {
            throwIn(e);
        }
    }
    //</editor-fold>

    @Override
    public Actor start() {
        return (Actor) super.start();
    }

    //<editor-fold desc="Lifecycle">
    /////////// Lifecycle ///////////////////////////////////
    @Override
    protected abstract V run() throws InterruptedException, SuspendExecution;

    protected void handleLifecycleMessage(LifecycleMessage m) {
        if (m instanceof ExitMessage)
            throw new LifecycleException(m);
    }

    @Override
    protected void onCompletion() {
        notifyDeath(null);
    }

    @Override
    protected void onException(Throwable t) {
        notifyDeath(t);
        Exceptions.rethrow(t);
    }

    @Override
    protected void postRestore() {
        super.postRestore();
        checkThrownIn();
    }

    public void throwIn(RuntimeException e) {
        this.thrownIn = e; // last exception thrown in wins
    }

    private void checkThrownIn() {
        if (thrownIn != null) {
            thrownIn.setStackTrace(new Throwable().getStackTrace());
            throw thrownIn;
        }
    }

    public Actor register(String name) {
        if (name == null)
            throw new IllegalArgumentException("name is null");
        registeredActors.put(name, this);
        return this;
    }

    public Actor register() {
        return register(getName());
    }

    public static void unregister(String name) {
        registeredActors.remove(name);
    }

    public static Actor getActor(String name) {
        return registeredActors.get(name);
    }

    public Actor link(Actor other) {
        lifecycleListeners.add(other.lifecycleListener);
        other.lifecycleListeners.add(lifecycleListener);
        return this;
    }

    public Actor unlink(Actor other) {
        lifecycleListeners.remove(other.lifecycleListener);
        other.lifecycleListeners.remove(lifecycleListener);
        return this;
    }
    private final LifecycleListener lifecycleListener = new LifecycleListener() {
        @Override
        public void dead(Actor actor, Object reason) {
            mailbox.send(new ExitMessage(actor, reason));
        }
    };

    public Object monitor(Actor other) {
        LifecycleListener listener = new LifecycleListener() {
            @Override
            public void dead(Actor actor, Object reason) {
                mailbox.send(new ExitMessage(actor, reason, this));
            }
        };
        other.lifecycleListeners.add(listener);
        return listener;
    }

    public void demonitor(Actor other, Object listener) {
        other.lifecycleListeners.remove(listener);
    }

    private void notifyDeath(Object reason) {
        for (LifecycleListener listener : lifecycleListeners)
            listener.dead(this, reason);
    }
    //</editor-fold>
}
